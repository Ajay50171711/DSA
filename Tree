Implementation of Tree
=================================================================

#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Create new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = newNode->right = NULL;
    return newNode;
}

int main() {
    // Root node
    struct Node* root = createNode(10);

    // Children
    root->left = createNode(20);
    root->right = createNode(30);

    root->left->left = createNode(40);
    root->left->right = createNode(50);

	root->right->left = createNode(60);
    root->right->right = createNode(70);


    printf("Root: %d\n", root->data);
    printf("Left Child: %d\n", root->left->data);
    printf("Right Child: %d\n", root->right->data);

	printf("Left Child->left: %d\n", root->left->left->data);
    printf("Left Child->right: %d\n", root->left->right->data);
	
	printf("Right Child->Left: %d\n", root->right->left->data);
    printf("Right Child->Right: %d\n", root->right->right->data);
	
    return 0;
}

============================================menu driven code===================================================
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a tree node
struct node {
    int data;
    struct node *left;
    struct node *right;
};

// Recursive function to create the binary tree
struct node *create() {
    int x;
    printf("Enter the data (enter -1 for no node): ");
    scanf("%d", &x);

    // If user enters -1, no node is created
    if (x == -1) {
        return NULL;
    }

    // Allocate memory for the new node
    struct node *newnode = (struct node *)malloc(sizeof(struct node));
    if (!newnode) {
        printf("Memory allocation failed!\n");
        exit(1);
    }

    newnode->data = x;

    // Recursively build left and right subtrees
    printf("Enter the left child of %d:\n", x);
    newnode->left = create();

    printf("Enter the right child of %d:\n", x);
    newnode->right = create();

    return newnode;
}

int main() {
    struct node *root = NULL;

    // Build the binary tree
    root = create();

    // At this point, 'root' points to the constructed binary tree
    // You can add operations here later (e.g., traversals, search, etc.)
    printf("\nBinary tree created successfully.\n");

    return 0;
}

==================================inorder/preorder/postorder traversal in binary tree===============================================

#include <stdio.h>
#include <stdlib.h>

struct node {
    int data;
    struct node *left;
    struct node *right;
};

struct node *create() {
    struct node *newnode;
    int x;

    printf("Enter the data (enter -1 for no node): ");
    scanf("%d", &x);

    if (x == -1) {
        return NULL;   // no node created
    }

    newnode = (struct node*) malloc(sizeof(struct node));
    newnode->data = x;

    printf("Enter the left child of %d:\n", x);
    newnode->left = create();

    printf("Enter the right child of %d:\n", x);
    newnode->right = create();

    return newnode;
}

// Preorder Traversal: Root -> Left -> Right
void preorder(struct node *root) {
    if (root == NULL) return;
    printf("%d ", root->data);
    preorder(root->left);
    preorder(root->right);
}

// Inorder Traversal: Left -> Root -> Right
void inorder(struct node *root) {
    if (root == NULL) return;
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
}

// Postorder Traversal: Left -> Right -> Root
void postorder(struct node *root) {
    if (root == NULL) return;
    postorder(root->left);
    postorder(root->right);
    printf("%d ", root->data);
}

int main() {
    struct node *root = NULL;

    root = create();

    printf("\nPreorder traversal:\n");
    preorder(root);

    printf("\nInorder traversal:\n");
    inorder(root);

    printf("\nPostorder traversal:\n");
    postorder(root);

    printf("\n");
    return 0;
}
=========================================================================================================================
