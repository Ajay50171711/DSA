Implementation of Tree
=================================================================

#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Create new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = newNode->right = NULL;
    return newNode;
}

int main() {
    // Root node
    struct Node* root = createNode(10);

    // Children
    root->left = createNode(20);
    root->right = createNode(30);

    root->left->left = createNode(40);
    root->left->right = createNode(50);

	root->right->left = createNode(60);
    root->right->right = createNode(70);


    printf("Root: %d\n", root->data);
    printf("Left Child: %d\n", root->left->data);
    printf("Right Child: %d\n", root->right->data);

	printf("Left Child->left: %d\n", root->left->left->data);
    printf("Left Child->right: %d\n", root->left->right->data);
	
	printf("Right Child->Left: %d\n", root->right->left->data);
    printf("Right Child->Right: %d\n", root->right->right->data);
	
    return 0;
}

============================================menu driven code===================================================
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a tree node
struct node {
    int data;
    struct node *left;
    struct node *right;
};

// Recursive function to create the binary tree
struct node *create() {
    int x;
    printf("Enter the data (enter -1 for no node): ");
    scanf("%d", &x);

    // If user enters -1, no node is created
    if (x == -1) {
        return NULL;
    }

    // Allocate memory for the new node
    struct node *newnode = (struct node *)malloc(sizeof(struct node));
    if (!newnode) {
        printf("Memory allocation failed!\n");
        exit(1);
    }

    newnode->data = x;

    // Recursively build left and right subtrees
    printf("Enter the left child of %d:\n", x);
    newnode->left = create();

    printf("Enter the right child of %d:\n", x);
    newnode->right = create();

    return newnode;
}

int main() {
    struct node *root = NULL;

    // Build the binary tree
    root = create();

    // At this point, 'root' points to the constructed binary tree
    // You can add operations here later (e.g., traversals, search, etc.)
    printf("\nBinary tree created successfully.\n");

    return 0;
}

==================================inorder/preorder/postorder traversal in binary tree===============================================

#include <stdio.h>
#include <stdlib.h>

struct node {
    int data;
    struct node *left;
    struct node *right;
};

struct node *create() {
    struct node *newnode;
    int x;

    printf("Enter the data (enter -1 for no node): ");
    scanf("%d", &x);

    if (x == -1) {
        return NULL;   // no node created
    }

    newnode = (struct node*) malloc(sizeof(struct node));
    newnode->data = x;

    printf("Enter the left child of %d:\n", x);
    newnode->left = create();

    printf("Enter the right child of %d:\n", x);
    newnode->right = create();

    return newnode;
}

// Preorder Traversal: Root -> Left -> Right
void preorder(struct node *root) {
    if (root == NULL) return;
    printf("%d ", root->data);
    preorder(root->left);
    preorder(root->right);
}

// Inorder Traversal: Left -> Root -> Right
void inorder(struct node *root) {
    if (root == NULL) return;
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
}

// Postorder Traversal: Left -> Right -> Root
void postorder(struct node *root) {
    if (root == NULL) return;
    postorder(root->left);
    postorder(root->right);
    printf("%d ", root->data);
}

int main() {
    struct node *root = NULL;

    root = create();

    printf("\nPreorder traversal:\n");
    preorder(root);

    printf("\nInorder traversal:\n");
    inorder(root);

    printf("\nPostorder traversal:\n");
    postorder(root);

    printf("\n");
    return 0;
}
=========================================================================================================================
implementation of binary tree by array representation 
======================================================

 1)       10
        /    \
       5      15
     /  \    /  \
    2    7  12  20


ðŸ“¦ Array Representation (Level-Order)
----------------------------------------------------------------
We represent the tree in array only for complete binary tree:
-----------------------------------------------------------------
Indexing starts at 0.

For a node at index i:
Left child is at 2*i + 1
Right child is at 2*i + 2
Parent node = (c - 1) // 2   where c is index of child node


Index: 0   1   2   3   4    5    6
Value: 10  5   15  2   7    12   20
--------------------------------------------------
          10
        /    \
       5      15
     /  \       \
    2    7       20
         /
        12

Index:  0   1   2   3   4   5    6   7   8   9   10
Value: 10  5   15  2   7  -1   20  -1  -1  12   -1


-------------------------------------------------------



Try it .........
              1
           /      \
         2               3
      /     \          /    \
     4       5       6      7
          /   \         \
         8     9         10
                \
                 11

------------------------------------------------------------------

How to find the maximum number of nodes in a binary tree at height h ?
How to find the minimum number of nodes in a binary tree at height h ?
-------------------------------------------------------------------------
Construct Binary tree from Preorder and Inorder
--------------------------------------------
Preorder: 1 2 4 5 3 6 7
Inorder: 4 2 5 1 6 3 7

        1
       / \
      2   3
     / \ / \
    4  5 6  7
--------------------------------------------------
Construct Binary tree from Postorder and Inorder
--------------------------------------------------
Inorder (Left â€“ Root â€“ Right)
[2, 5, 7, 9, 10, 15, 20]

Postorder (Left â€“ Right â€“ Root)
[2, 9, 7, 5, 20, 15, 10]


        10
       /  \
      5    15
     / \     \
    2   7     20
         \
          9
-------------------------------------------------
Construct Binary tree from Postorder and preorder
-------------------------------------------------
Impossible to construct uniquely from only preorder and postorder.

but we can create unique representaion of full binary tree
---------------------------------------------------------------
Preorder (Root â†’ Left â†’ Right):
A B D E H I C F G

Postorder (Left â†’ Right â†’ Root):
D H I E B F G C A

            A
          /   \
         B     C
        / \   / \
       D   E F   G
          / \
         H   I
--------------------------------------------------------------------------
construct  a binary search tree by only Preoreder 
----------------------------------------------------

Preorder (Rootâ€“Leftâ€“Right): 15, 10, 8, 12, 20, 17, 25
(In a BST, the inorder is always the sorted sequence of node values.)
Inorder (Leftâ€“Rootâ€“Right): 8, 10, 12, 15, 17, 20, 25

        15
       /  \
     10    20
    /  \   / \
   8   12 17 25
-------------------------------------------------------------------------------
construct  a binary search tree by only Postoreder 
----------------------------------------------------
Postorder (Leftâ€“Rightâ€“Root): 2, 7, 5, 12, 20, 15, 10

Inorder (Leftâ€“Rootâ€“Right): 2, 5, 7, 10, 12, 15, 20

          10
         /  \
        5    15
       / \   / \
      2   7 12 20
-----------------------------------------------------------------------------------------------------------------------
